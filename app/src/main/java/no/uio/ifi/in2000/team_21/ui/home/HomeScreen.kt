package no.uio.ifi.in2000.team_21.ui.home


import android.app.TimePickerDialog
import android.content.Context
import android.graphics.drawable.ColorDrawable
import android.net.ConnectivityManager
import android.net.NetworkCapabilities
import no.uio.ifi.in2000.team_21.ui.viewmodels.LocationViewModel
import android.os.Build
import android.util.Log
import androidx.annotation.RequiresApi
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.aspectRatio
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.sizeIn
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material.icons.filled.Warning
import androidx.compose.material.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.livedata.observeAsState
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import no.uio.ifi.in2000.team_21.Screen
import no.uio.ifi.in2000.team_21.model.AlertsInfo
import no.uio.ifi.in2000.team_21.ui.map.AlertsViewModel

import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.scale
import androidx.compose.ui.platform.LocalContext
import no.uio.ifi.in2000.team_21.model.activity.ConditionStatus

import no.uio.ifi.in2000.team_21.ui.theme.Background
import no.uio.ifi.in2000.team_21.ui.theme.ContainerBlue
import no.uio.ifi.in2000.team_21.ui.theme.WeatherCard
import no.uio.ifi.in2000.team_21.ui.theme.MidnightBlue
import no.uio.ifi.in2000.team_21.ui.theme.YellowAlert
import no.uio.ifi.in2000.team_21.ui.theme.GreenAlert
import no.uio.ifi.in2000.team_21.ui.theme.RedAlert

import no.uio.ifi.in2000.team_21.ui.viewmodels.ActivitiesViewModel
import no.uio.ifi.in2000.team_21.ui.viewmodels.ActivityConditionCheckerViewModel
import no.uio.ifi.in2000.team_21.ui.viewmodels.ForecastViewModel
import no.uio.ifi.in2000.team_21.ui.viewmodels.OceanForecastViewModel

import java.time.ZoneId
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter
import java.time.temporal.ChronoUnit
import kotlin.random.Random
import no.uio.ifi.in2000.team_21.ui.home.ActivityIconGridHorizontalSmall
import java.time.LocalDate
import java.time.LocalTime

@Composable
fun WeatherCard(
    cityName: String,
    temperature: String,
    alertColor: Color,
    isAlertActive: Boolean = false,
    icon: String,
    cloudCoverDescription: String,
    waveheight: String,
    windSpeed: String
) {

    Row(
        horizontalArrangement = Arrangement.Center,
        modifier = Modifier
            .fillMaxWidth()
    ){

        Card(
            modifier = Modifier
                .padding(40.dp)
                .width(320.dp),
            elevation = CardDefaults.cardElevation(defaultElevation = 16.dp),
            colors = CardDefaults.cardColors(containerColor = alertColor)
        ) {
            Column (
                modifier = Modifier
                    .padding(16.dp)
                    .fillMaxWidth(),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    text = cityName,
                    style = TextStyle(
                        fontSize = 18.sp,
                        lineHeight = 20.sp,
                        //fontFamily = FontFamily(Font(R.font.roboto)),
                        fontWeight = FontWeight(400),
                        color = MidnightBlue,
                        textAlign = TextAlign.Center,
                        letterSpacing = 0.1.sp,
                    )
                )
                Spacer(Modifier.height(16.dp))
                Box(
                    contentAlignment = Alignment.CenterStart,
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(start = 20.dp)
                ) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.Start,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        WeatherIcon(
                            element = icon
                        )
                        Spacer(modifier = Modifier.padding(12.dp))
                        Text(
                            text = temperature,
                            style = TextStyle(
                                fontSize = 70.sp,
                                lineHeight = 16.sp,
                                //fontFamily = FontFamily(Font(R.font.roboto)),
                                //fontWeight = FontWeight(400),
                                color = MidnightBlue,
                                textAlign = TextAlign.Center,
                                letterSpacing = 0.5.sp,
                            ),
                        )
                        if (isAlertActive) {
                            Icon(
                                imageVector = Icons.Default.Warning,
                                contentDescription = "Alert active",
                                modifier = Modifier
                                    .padding(start = 16.dp)
                                    .size(40.dp)
                            )
                        }
                    }
                }
                Spacer(Modifier.height(4.dp))
                Text(
                    text = cloudCoverDescription,
                    style = TextStyle(
                        fontSize = 16.sp,
                        lineHeight = 20.sp,
                        //fontFamily = FontFamily(Font(R.font.roboto)),
                        fontWeight = FontWeight(400),
                        color = MidnightBlue,
                        textAlign = TextAlign.Center,
                        letterSpacing = 0.1.sp,
                    )
                )
                Spacer(Modifier.height(4.dp))

                Row(

                ) {

                    Text(
                        text = "Vind: " + windSpeed,
                        style = TextStyle(
                            fontSize = 16.sp,
                            lineHeight = 20.sp,
                            //fontFamily = FontFamily(Font(R.font.roboto)),
                            fontWeight = FontWeight(400),
                            color = MidnightBlue,
                            textAlign = TextAlign.Center,
                            letterSpacing = 0.1.sp,
                        ),
                        modifier = Modifier
                            .weight(1f)
                    )

                    if ( !waveheight.contains("null")){
                        Text(
                            text = "BÃ¸lger: " + waveheight,
                            style = TextStyle(
                                fontSize = 16.sp,
                                lineHeight = 20.sp,
                                //fontFamily = FontFamily(Font(R.font.roboto)),
                                fontWeight = FontWeight(400),
                                color = MidnightBlue,
                                textAlign = TextAlign.Center,
                                letterSpacing = 0.1.sp,
                            ),
                            modifier = Modifier
                                .weight(1f)
                        )
                    }
                }
            }
        }
    }
}


@Composable
fun ActivityFavorites(
    viewModel: ActivitiesViewModel,
    navController: NavController,
    activityConditionCheckerViewModel: ActivityConditionCheckerViewModel
) {
    Column(
        modifier = Modifier.fillMaxWidth()
    ) {

        Row(
            modifier = Modifier
                .fillMaxWidth()
        ) {
            Text(
                text = "Dine favoritter",
                style = TextStyle(
                    fontSize = 20.sp,
                    lineHeight = 20.sp,
                    //fontFamily = FontFamily(Font(R.font.roboto)),
                    //fontWeight = FontWeight(400),
                    color = MidnightBlue,
                    //textAlign = TextAlign.Center,
                    letterSpacing = 0.1.sp,
                ),
                modifier = Modifier
                    .padding(8.dp)
            )

            Button(
                onClick = {
                    navController.navigate(Screen.AddActivityScreen.route)
                          },
                colors = ButtonDefaults.buttonColors(
                    containerColor = Background,
                    contentColor = MidnightBlue
                ),
                modifier = Modifier
                    .offset(x = 200.dp)
            ) {
                Icon(
                    imageVector = Icons.Default.Add,
                    contentDescription = "Button add to favorites",
                    modifier = Modifier
                        .padding(1.dp)
                        .scale(1.5f)
                )
            }

        }

        ActivityIconGridHorizontalSmall(
            navController = navController,
            activitiesViewModel = viewModel
        )

    }
}

@Composable
fun RecommendationSection(
    viewModel: ActivitiesViewModel,
    activityConditionCheckerViewModel: ActivityConditionCheckerViewModel,
    locationViewModel: LocationViewModel,
    navController: NavController
) {

    val weatherFacts = listOf(
        "De beste seilforholdene oppstÃ¥r ofte nÃ¥r det er en jevn bris pÃ¥ 10-20 knop. Denne vindhastigheten ikke bare driver bÃ¥ter jevnt, men gir ogsÃ¥ behagelig motstand for mer spennende seilopplevelser.",
        "Visste du at vann beholder varme lenger enn luft? Selv pÃ¥ en kjÃ¸ligere dag kan vannet i innsjÃ¸er og hav vÃ¦re behagelig varmt, noe som gjÃ¸r det mulig for en komfortabel svÃ¸mmetur.",
        "Vann leder elektrisitet, noe som gjÃ¸r det farlig under tordenvÃ¦r. Statistisk sett skjer flertallet av lynskader og dÃ¸dsfall pÃ¥ vannet i smÃ¥ bÃ¥ter uten kabin.",
        "TÃ¥ke er vanligere nÃ¦r vannkropper fordi vannpartikler som er suspendert i luften kjÃ¸ler ned den omkringliggende temperaturen, noe som kondenserer luftfuktigheten. Roere lÃ¦rer Ã¥ lytte etter lydene av andre bÃ¥ters horn og Ã¥ holde seg nÃ¦r land for Ã¥ navigere trygt i tÃ¥ke.",
        "TidevannsstrÃ¸mmer kan pÃ¥virke kajakkopplevelsen din betraktelig. Ã padle med tidevannet kan hjelpe deg Ã¥ bevege deg raskere og med mindre innsats, mens det Ã¥ padle mot tidevannet kan vÃ¦re en skikkelig treningsÃ¸kt!",
        "UV-strÃ¥ler reflekterer av vannoverflaten, noe som Ã¸ker eksponeringen din. Dette betyr at entusiaster for vannsport trenger Ã¥ pÃ¥fÃ¸re solkrem mer rikelig og oftere enn nÃ¥r de er pÃ¥ land.",
        "Fisk er mer sannsynlig Ã¥ bite nÃ¥r det er et plutselig fall i trykket, noe som ofte kommer fÃ¸r dÃ¥rlig vÃ¦r. Dette er et nyttig tips for kajakfiskere for Ã¥ planlegge sine turer.",
        "HÃ¸y fuktighet kan gjÃ¸re at det fÃ¸les mye varmere enn det faktisk er fordi svette ikke fordamper raskt for Ã¥ kjÃ¸le ned kroppen. Dette er spesielt viktig for vannsport, da det kan pÃ¥virke hydrering og energinivÃ¥er.",
        "Ãkt vindstyrke kan skape hÃ¸yere bÃ¸lger, noe som er ideelt for mer avanserte kajakkpadlere som sÃ¸ker utfordringer.",
        "I kaldere klima kan sjÃ¸vann noen ganger holde seg over frysepunktet selv nÃ¥r lufttemperaturen faller under null, takket vÃ¦re saltinnholdet som senker frysepunktet.",
        "Sikten under vann kan forbedres betydelig nÃ¥r vindstyrken avtar og vannet blir roligere, noe som er perfekt for snorkling og dykking.",
        "Regn kan pÃ¥virke vannets salinitet (saltinnhold), spesielt nÃ¦r kysten, noe som kan pÃ¥virke marine Ã¸kosystemer og den lokale fiskeaktiviteten.",
        "Soloppgang og solnedgang er ofte de beste tidene for padling fordi vindforholdene er roligere og temperaturen er mer behagelig.",
        "Langvarig eksponering for kaldt vann kan redusere kroppstemperaturen og Ã¸ke risikoen for hypotermi, selv for svÃ¸mmere som er vant til kaldt vann.",
        "MÃ¥nefasene kan dramatisk pÃ¥virke tidevannsstyrken, noe som er viktig Ã¥ vurdere nÃ¥r man planlegger aktiviteter som krever at man gÃ¥r inn og ut av vannet.",
        "Rask endring i lufttrykk kan fÃ¸re til raskt skiftende vÃ¦rforhold pÃ¥ vannet, noe som krever at vannsportentusiaster alltid mÃ¥ vÃ¦re forberedt pÃ¥ endringer.",
        "Duggpunktet kan fortelle mye om hvor raskt vÃ¦ret vil endre seg, spesielt viktig for de som planlegger langvarige aktiviteter pÃ¥ vannet.",
        "Algerblomstring, som ofte oppstÃ¥r under spesielle temperatur- og nÃ¦ringsforhold, kan gjÃ¸re vannet farlig for svÃ¸mming og andre vannaktiviteter.",
        "Under varmebÃ¸lger kan sjÃ¸vannet bli sÃ¥ varmt at det stimulerer overdreven vekst av bakterier, noe som kan gjÃ¸re vannet usikkert for bading.",
        "Stormer kan skape ideelle forhold for surfeentusiaster, da de ofte fÃ¸rer med seg stÃ¸rre og mer kraftfulle bÃ¸lger.",
        "Isdannelse pÃ¥ innsjÃ¸er starter ved kantene og vokser innover, og tykkelsen kan variere sterkt, noe som er viktig for isfiskere og skÃ¸yteentusiaster Ã¥ merke seg.",
        "Ã seile ved fullmÃ¥ne kan gi en spektakulÃ¦r nattseilasopplevelse, da mÃ¥nelyset reflekterer over vannflaten og forbedrer synligheten.",
        "Vannsprut fra kraftige bÃ¸lger kan redusere synligheten betydelig, noe som gjÃ¸r navigasjon pÃ¥ vannet mer utfordrende under stormfulle forhold.",
        "Lyden av bÃ¸lger er hÃ¸yere nÃ¥r lufttemperaturen er lavere, da kaldere luft er tyngre og bÃ¦rer lyd bedre.",
        "Termiske vinder, som oppstÃ¥r nÃ¥r varm luft stiger og kaldere luft strÃ¸mmer inn for Ã¥ erstatte den, kan gi perfekte forhold for kite- og vindsurfing.",
        "MorgentÃ¥ke langs elver og innsjÃ¸er kan ofte indikere en klar dag fremover, da tÃ¥ken dannes nÃ¥r nattens kjÃ¸lige temperatur mÃ¸ter varmere vann.",
        "Vannet kan virke mÃ¸rkere fÃ¸r stormer pÃ¥ grunn av skyggen fra tykke skyer, noe som kan pÃ¥virke synligheten for dykkere og snorklere.",
        "HÃ¸yere luftfuktighet kan fÃ¸re til at kroppen fÃ¸ler seg klam under vannsport, selv i relativt kjÃ¸lige forhold."
    )

    fun getRandomWeatherFact(): String {
        return weatherFacts[Random.nextInt(weatherFacts.size)]
    }

    Column(
         ) {
        Text(
            text = "VÃ¥re anbefalinger",
            style = TextStyle(
                fontSize = 20.sp,
                lineHeight = 20.sp,
                //fontFamily = FontFamily(Font(R.font.roboto)),
                fontWeight = FontWeight(400),
                color = MidnightBlue,
                textAlign = TextAlign.Center,
                letterSpacing = 0.1.sp,
            )
        )
        //Spacer(Modifier.height(4.dp))

        val activityList by activityConditionCheckerViewModel.activities.observeAsState(initial = emptyList())
        val filteredActivities = activityList.filter {
            it.conditionStatus == ConditionStatus.ALL_MET
        }

        if(filteredActivities.isEmpty()){
            Card(
                colors = CardDefaults.cardColors(ContainerBlue),
                modifier = Modifier
                    .padding(start = 8.dp, bottom = 8.dp, end = 8.dp)
            ) {

                Spacer(modifier = Modifier.height(8.dp))
                Text(
                    text = "Ingen aktiviteter kan anbefales akkurat nÃ¥. Dette kan skyldes upassende vÃ¦r eller manglende nettverkstilkobling.",
                    color = MidnightBlue,

                )
                Spacer(
                    modifier = Modifier
                        .height(8.dp)
                )
                Text(
                    text = "Mens du venter, her er en fakta om vÃ¦r ved sjÃ¸en",
                    color = MidnightBlue,
                )
                Spacer(
                    modifier = Modifier
                        .height(8.dp)
                )
                Text(
                    text = getRandomWeatherFact(),
                    color = MidnightBlue,
                )
            }
        }else{
            LazyRow {
                this.items(filteredActivities){ recommendation ->
                    ActivityCardSmall(
                        activity = recommendation,
                        navController = navController
                    )
                }
            }
        }
    }
}

@Composable
fun HomeScreen(
    navController: NavController,
    activitiesViewModel: ActivitiesViewModel,
    forecastViewModel: ForecastViewModel,
    alertsViewModel: AlertsViewModel,
    locationViewModel: LocationViewModel,
    activityConditionCheckerViewModel: ActivityConditionCheckerViewModel,
    oceanForecastViewModel: OceanForecastViewModel
) {

    val norwayZone = ZoneId.of("Europe/Oslo")

    val dateFormatterBackEnd = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH").withZone(norwayZone)

    val time = ZonedDateTime.now(norwayZone).truncatedTo(ChronoUnit.HOURS).format(dateFormatterBackEnd)

    val userLocation by locationViewModel.userLocation.collectAsState()
    val filteredFeatures by alertsViewModel.filteredFeatures.observeAsState()
    val oceanData by oceanForecastViewModel.oceanDataState.observeAsState()
    val currentCityName by locationViewModel.currentCityName.collectAsState()
    val currentForcastResponse by forecastViewModel.forecast.collectAsState()

    // Tidsformat: yyyy-MM-dd'T'HH

    var selectedDate by remember { mutableStateOf(LocalDate.now()) }
    var selectedTime by remember { mutableStateOf(LocalTime.now()) }
    var isDatePickerOpen by remember { mutableStateOf(false) }
    var isTimePickerOpen by remember { mutableStateOf(false) }
    val dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd")
    val dateFormatterFrontEnd = DateTimeFormatter.ofPattern("dd-MM-yyyy")
    val timeFormatter = DateTimeFormatter.ofPattern("HH")
    val context = LocalContext.current

    var showNoNetworkDialog by remember {
        mutableStateOf(false)
    }
    
    var selected_time by remember {
        mutableStateOf(time)
    }

    val currentForecast by remember{
        derivedStateOf {
            currentForcastResponse?.properties?.timeseries?.find {
                it.time?.contains(selected_time) ?: false
            }
        }
    }


    Log.d(
        "HOME_SCREEN",
        "oceanData: ${oceanData?.properties?.timeseries}"
    )

    val isAlertActive = remember(filteredFeatures) {
        filteredFeatures?.isNotEmpty() == true
    }

    LaunchedEffect(userLocation, selected_time) {
        if (userLocation != null) {
            alertsViewModel.fetchAndFilterAlerts(
                AlertsInfo(),
                userLocation!!,
                radius = 20.0
            )
            Log.d("HOME_SCREEN", "User location: ${userLocation!!.latitude()}, ${userLocation!!.longitude()}")

            forecastViewModel.continuousForecastUpdate( // let him cook!
                latitude = userLocation!!.latitude(),
                longitude = userLocation!!.longitude()
            )

            activityConditionCheckerViewModel.checkActivityConditions(
                time = time,
                latitude = userLocation!!.latitude() ,
                longitude = userLocation!!.longitude()
            )

            oceanForecastViewModel.fetchOceanForecastByTime(
                latitude = userLocation!!.latitude(),
                longitude = userLocation!!.longitude()
            )

        }
    }

    if (showNoNetworkDialog){
        AlertDialog(
            onDismissRequest = {
                showNoNetworkDialog = false
                if (userLocation != null){

                    forecastViewModel.fetchWeatherForLocation( // let him cook!
                        lat = userLocation!!.latitude(),
                        lon = userLocation!!.longitude()
                    )

                    oceanForecastViewModel.fetchOceanForecastByTime(
                        latitude = userLocation!!.latitude(),
                        longitude = userLocation!!.longitude()
                    )

                    activityConditionCheckerViewModel.checkActivityConditions(
                        time = selected_time,
                        latitude = userLocation!!.latitude() ,
                        longitude = userLocation!!.longitude()
                    )

                }
            },
            title = { Text(text = "Ingen nettverksforbindelse")},
            text = { Text(text = "Vi kan ikke hente vÃ¦rdata, sjekk din nettverkstilkobling og prÃ¸v igjen. ")},
            buttons = {
                Button(onClick = { showNoNetworkDialog = false }) {
                    Text(text = "Lukk")
                }
            }
        )
    }

    val alertColor = when (filteredFeatures?.maxByOrNull { it.properties.severity?.toIntOrNull() ?: 0 }?.properties?.riskMatrixColor) {
        "Yellow" -> YellowAlert // Yellow
        "Red" -> RedAlert // Red
        "Green" -> GreenAlert// Green
        else -> WeatherCard// Default case
    }

        Column(
            modifier = Modifier
                .width(360.dp)
                .height(50.dp)
                .background(color = Background)
        ) {
            TopBarComponent(
                navController = navController
            )

            if (currentForcastResponse != null) {
                WeatherCard(
                    cityName = currentCityName ?: "---",
                    temperature = when (currentForcastResponse?.properties?.meta?.units?.air_temperature) {
                        "celsius" -> "${
                            currentForecast?.data?.instant?.details?.air_temperature?.toInt()
                                .toString()
                        }Â°"

                        else -> currentForecast?.data?.instant?.details?.air_temperature?.toInt()
                            .toString()
                    },
                    alertColor = alertColor,
                    isAlertActive = isAlertActive,
                    cloudCoverDescription = forecastViewModel.describeCloudCover(
                        currentForecast?.data?.instant?.details?.cloud_area_fraction ?: 1.1
                    ),
                    icon = currentForecast?.data?.next_1_hours?.summary?.symbol_code ?: "",
                    waveheight = "${oceanData?.properties?.timeseries?.find { it.time?.contains(time) ?: false }?.data?.instant?.details?.sea_surface_wave_height} ${oceanData?.properties?.meta?.units?.sea_surface_wave_height}",
                    windSpeed = "${currentForecast?.data?.instant?.details?.wind_speed} ${currentForcastResponse?.properties?.meta?.units?.wind_speed}"
                )
            } else {
                showNoNetworkDialog = true
            }

            Row(
                horizontalArrangement = Arrangement.Center,
                modifier = Modifier
                    .padding(start = 100.dp, end = 40.dp)
            ) {

                OutlinedTextField(
                    readOnly = true,
                    value = selectedDate.format(dateFormatterFrontEnd),
                    onValueChange = {},
                    modifier = Modifier
                        .clickable {
                            isDatePickerOpen = true
                            Log.d("HS", "trykket datofelt")
                        }
                        .width(130.dp)
                        .height(60.dp),
                    label = { Text("Dato") },
                    shape = RoundedCornerShape(16.dp)
                )

                Spacer(modifier = Modifier.width(8.dp))

                OutlinedTextField(
                    readOnly = true,
                    value = selectedTime.format(timeFormatter),
                    onValueChange = {},
                    modifier = Modifier
                        .clickable { isTimePickerOpen = true }
                        .width(66.dp)
                        .height(60.dp),
                    label = { Text("Tid") },
                    shape = RoundedCornerShape(16.dp)
                )

            }

            if (isDatePickerOpen) {
                val datePickerDialog = android.app.DatePickerDialog(
                    context,
                    { _, year, month, dayOfMonth ->
                        selectedDate = LocalDate.of(year, month + 1, dayOfMonth)
                        isDatePickerOpen = false
                    },
                    selectedDate.year,
                    selectedDate.monthValue - 1,
                    selectedDate.dayOfMonth
                )
                datePickerDialog.show()
                isDatePickerOpen = false
            }

            if (isTimePickerOpen) {
                val timePickerDialog = TimePickerDialog(
                    context,
                    { _, hourOfDay, minute ->
                        selectedTime = LocalTime.of(hourOfDay, 0)
                        isTimePickerOpen = false
                    },
                    selectedTime.hour,
                    selectedTime.minute,
                    true
                )
                timePickerDialog.show()
                isTimePickerOpen = false
            }

            selected_time = selectedDate.atTime(selectedTime).format(dateFormatter)

            Log.d("HS", "selected time: $selected_time")

            ActivityFavorites(
                viewModel = activitiesViewModel,
                navController = navController,
                activityConditionCheckerViewModel = activityConditionCheckerViewModel
            )

            RecommendationSection(
                viewModel = activitiesViewModel,
                activityConditionCheckerViewModel = activityConditionCheckerViewModel,
                locationViewModel = locationViewModel,
                navController = navController
            )
        }

}

